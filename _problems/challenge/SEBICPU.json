{"category_name":"challenge","status":"success","problem_code":"SEBICPU","problem_name":"(Challenge) Sebi and CPU Design","body":"### Read problem statements in [Mandarin Chinese](https:\/\/www.codechef.com\/download\/translated\/SEPT19\/mandarin\/SEBICPU.pdf), [Bengali](https:\/\/www.codechef.com\/download\/translated\/SEPT19\/bengali\/SEBICPU.pdf), [Russian](https:\/\/www.codechef.com\/download\/translated\/SEPT19\/russian\/SEBICPU.pdf), and [Vietnamese](https:\/\/www.codechef.com\/download\/translated\/SEPT19\/vietnamese\/SEBICPU.pdf) as well.\n\nThe King of Chefland is a fan of triplets, especially Pythagorean triplets. His son, prince Sebi, designed the first CPU of Chefland.\n\nNobody wants to argue with the son of the king, so everybody agrees that he is a great hardware designer. However, he forgot a lot of important instructions, like assigning a constant to a register. Chefland is now looking for a programmer who can load some given triplets to registers quickly.\n\n**Architecture of Sebi's CPU:**\n- There are four 64-bit registers based on the [X64 architecture](https:\/\/docs.microsoft.com\/en-us\/windows-hardware\/drivers\/debugger\/x64-architecture). These registers are named `rax`, `rbx`, `rcx` and `rdx`.\n- Parts of each 64-bit register can be used as smaller registers. For `y` equal to `a`, `b`, `c` or `d`, we have the following registers:\n    - `eyx`: the lower (least significant) 32 bits of `ryx`\n    - `yx`: the lower 16 bits of `ryx`\n    - `yl`: the lower 8 bits of `ryx`\n    - `yh`: the upper 8 bits of `yx`\n- The CPU cannot access any memory storage other than these registers.\n- The CPU supports several instructions based on assembly languages. Each instruction takes one or two registers as operands. Immediate values as operands are not supported. If an instruction takes two operands, they do not have to be distinct.\n- If an instruction takes two operands, they must have registers with the same width (number of bits). When the operands of an instruction are registers with width $b$, the values stored in them are treated as unsigned $b$-bit integers.\n- An instruction on registers with width $b$ computes a result \u2015 an unsigned $b$-bit integer \u2015 and stores it in the register given as the first operand. In case of overflow or underflow, the result is treated as computed modulo $2^b$; all bits outside the first-operand register remain unchanged.\n- The available one-operand instructions and their results are:\n    - `dec reg`: `reg` minus $1$\n    - `inc reg`: `reg` plus $1$\n    - `not reg`: bitwise NOT of `reg`\n- The available two-operand instructions and their results are:\n    - `and reg1 reg2`: bitwise AND of `reg1` and `reg2`\n    - `or reg1 reg2`: bitwise OR of `reg1` and `reg2`\n    - `xor reg1 reg2`: bitwise XOR of `reg1` and `reg2`\n    - `shl reg1 reg2`: `reg1` shifted left by `reg2` bits (and inserts `reg2` $0$-s as the least significant bits)\n    - `shr reg1 reg2`: `reg1` shifted right by `reg2` bits (and inserts `reg2` $0$-s as the most significant bits)\n    - `add reg1 reg2`: `reg1` plus `reg2`\n    - `sub reg1 reg2`: `reg1` minus `reg2`\n    - `mul reg1 reg2`: `reg1` multiplied by `reg2`\n    - `div reg1 reg2`: `reg1` divided by `reg2` (integer division)\n    - `mod reg1 reg2`: `reg1` modulo `reg2` (remainder of `reg1` after division by `reg2`)\n    - `mov reg1 reg2`: `reg2` (the instruction copies the value of `reg2` to `reg1`)\n- The only operations where the result could overflow are `shl`, `add`, `sub`, `mul`, `inc` and `dec`. In `sub` and `dec`, the result of $i-j$ modulo $2^b$ for $j \\gt i$ is $2^b + i - j$. In all other instructions, modulo simply corresponds to discarding all except the least significant $b$ bits.\n- It is not allowed to use the `div` or `mod` operation if `reg2` contains $0$.\n\nInitially, all four registers contain $0$-s. You are given $N$ triplets of 64-bit integers $(a_1, b_1, c_1), (a_2, b_2, c_2), \\ldots, (a_N, b_N, c_N)$ and you should write a program (a sequence of instructions) such that each triplet appears in the registers at some point during the execution of this program. The order in which they appear does not matter. Formally, for each valid $i$, there should be an instruction in your program such that **immediately** after this instruction is executed, one of the registers contains the value $a_i$, one contains $b_i$ and one contains $c_i$ (the fourth register may contain anything).\n\n### Input\n- The first line of the input contains a single integer $N$.\n- $N$ lines follow. For each $i$ ($1 \\le i \\le N$), the $i$-th of these lines contains three space-separated integers $a_i$, $b_i$ and $c_i$.\n\n### Output\n- First, print a line containing a single integer $P$ \u2015 the number of instructions in your program.\n- Then, print $P$ lines. For each valid $i$, the $i$-th of these lines should contain the $i$-th instruction from your program in the format described above.\n\n### Constraints\n- $N = 64$\n- $0 \\le a_i, b_i, c_i \\lt 2^{64}$ for each valid $i$\n- $a_i \\neq b_i$, $b_i \\neq c_i$, $a_i \\neq c_i$ for each valid $i$\n\n### Scoring\nIf your program attempts to divide anything by zero or compute anything modulo zero, your submission will receive the Wrong Answer verdict.\n\nIf $P$ exceeds $N \\cdot 500$, your submission will also receive the Wrong Answer verdict. Otherwise, the score of your program is equal to $P$. Your goal is to minimise this number.\n\nThere are ten test files. During the contest, the displayed score will account for exactly three test files. However, if your program gets a non-AC verdict on any test file, your submission's verdict will be non-AC. In other words, an AC verdict denotes that your program runs successfully on all the test files. After the end of the contest, your score will be changed to include the sum of your program's scores over the other 7 test files.\n\n### Generation\nThere are five types of test files and two files of each type.\n- Type 1: Each triplet is chosen uniformly randomly among all valid triplets.\n- Type 2: For each valid $i$:\n    - $a_i$ is chosen uniformly randomly among all 64-bit integers which contain at least 25 0-bits and at least 25 1-bits.\n    - $b_i$ and $c_i$ are chosen uniformly randomly among all pairs of distinct 64-bit integers which only differs from $a_i$ in one or two bits.\n- Type 3: For each valid $i$:\n    - If $i = 1 + 8k$ for some integer $k$, an unsigned integer $d$ ($1 \\le d \\lt 2^{63}$) is chosen uniformly randomly. This integer is used for this triplet and the next seven triplets.\n    - First, $a_i$ is chosen uniformly randomly; $b_i = a_i + d$ and $c_i = a_i + 2d$. If $c_i \\ge 2^{64}$, $a_i$ is chosen uniformly randomly again and $b_i$ and $c_i$ are updated.\n    - This process is repeated until $c_i \\lt 2^{64}$.\n- Type 4:\n    - First, three 64-bit unsigned integers are chosen uniformly randomly and assigned to three registers. The fourth register is unused; we may assume that it does not exist. Consider the following program which generates a list $L$:\n        - If $L$ contains $9N$ integers, terminate.\n        - Randomly choose two registers in some order. Randomly choose to use the whole registers or their lower 32 bits.\n        - Randomly choose one of the instructions `xor`, `and`, `or`, `add` or `sub` and execute it with the chosen registers as operands.\n        - Add the values in the three registers (in a fixed order) to the list $L$.\n    - Consider every third element of the list $L$. The first three of these integers form the first triplet, the next three form the second triplet and so on.\n    - While any triplet contains two equal elements, this process is repeated and the triplets regenerated.\n- Type 5:\n    - A 64-bit unsigned integer $K$ is chosen uniformly randomly.\n    - Each triplet is chosen uniformly randomly among all valid triplets with sum of all three elements equal to $K$.\n\n### Example Input 1\n```\n3\n255 2 4\n1 0 3\n2 6 3\n```\n\n### Example Output 1\n```\n10\ndec al\ninc rcx\ninc ecx\nmov rdx rcx\nadd rcx rdx\nadd rcx rdx\nmov rbx rcx\ndiv rbx rdx\ndiv rdx rdx\ndiv rcx rax\n```\n\n### Example Input 2\n```\n1\n18446743995541146810 18446743995541146811 18446743995541146809\n```\n\n### Example Output 2\n```\n13\ndec ebx\nadd bx bx\nmul rbx rbx\nnot ebx\nsub eax ebx\ndiv ebx eax\nmul ebx ebx\nsub ebx eax\nmul rax rbx\nmov rdx rax\ndec rax\nmov rbx rax\ndec rbx\n```\n\n### Explanation\nNote that $N \\neq 64$ to keep the input short. This constraint holds for all input files.\n\n**Example case 1:** The 64-bit values stored in the registers `(rax, rbx, rcx, rdx)` after each instruction is executed are as follows:\n```\ndec al                 (255, 0, 0, 0)\ninc rcx                (255, 0, 1, 0)\ninc ecx                (255, 0, 2, 0)\nmov rdx rcx            (255, 0, 2, 2)\nadd rcx rdx            (255, 0, 4, 2) \u2015 the first triplet appears\nadd rcx rdx            (255, 0, 6, 2)\nmov rbx rcx            (255, 6, 6, 2)\ndiv rbx rdx            (255, 3, 6, 2) \u2015 the third triplet appears\ndiv rdx rdx            (255, 3, 6, 1)\ndiv rcx rax            (255, 3, 0, 1) \u2015 the second triplet appears\n```\n\n<aside style='background: #f8f8f8;padding: 10px 15px;'><div>All submissions for this problem are available.<\/div><\/aside>","problemComponents":{"constraints":"","constraintsState":false,"subtasks":"","subtasksState":false,"statement":"### Read problem statements in [Mandarin Chinese](https:\/\/www.codechef.com\/download\/translated\/SEPT19\/mandarin\/SEBICPU.pdf), [Bengali](https:\/\/www.codechef.com\/download\/translated\/SEPT19\/bengali\/SEBICPU.pdf), [Russian](https:\/\/www.codechef.com\/download\/translated\/SEPT19\/russian\/SEBICPU.pdf), and [Vietnamese](https:\/\/www.codechef.com\/download\/translated\/SEPT19\/vietnamese\/SEBICPU.pdf) as well.\n\nThe King of Chefland is a fan of triplets, especially Pythagorean triplets. His son, prince Sebi, designed the first CPU of Chefland.\n\nNobody wants to argue with the son of the king, so everybody agrees that he is a great hardware designer. However, he forgot a lot of important instructions, like assigning a constant to a register. Chefland is now looking for a programmer who can load some given triplets to registers quickly.\n\n**Architecture of Sebi's CPU:**\n- There are four 64-bit registers based on the [X64 architecture](https:\/\/docs.microsoft.com\/en-us\/windows-hardware\/drivers\/debugger\/x64-architecture). These registers are named `rax`, `rbx`, `rcx` and `rdx`.\n- Parts of each 64-bit register can be used as smaller registers. For `y` equal to `a`, `b`, `c` or `d`, we have the following registers:\n    - `eyx`: the lower (least significant) 32 bits of `ryx`\n    - `yx`: the lower 16 bits of `ryx`\n    - `yl`: the lower 8 bits of `ryx`\n    - `yh`: the upper 8 bits of `yx`\n- The CPU cannot access any memory storage other than these registers.\n- The CPU supports several instructions based on assembly languages. Each instruction takes one or two registers as operands. Immediate values as operands are not supported. If an instruction takes two operands, they do not have to be distinct.\n- If an instruction takes two operands, they must have registers with the same width (number of bits). When the operands of an instruction are registers with width $b$, the values stored in them are treated as unsigned $b$-bit integers.\n- An instruction on registers with width $b$ computes a result \u2015 an unsigned $b$-bit integer \u2015 and stores it in the register given as the first operand. In case of overflow or underflow, the result is treated as computed modulo $2^b$; all bits outside the first-operand register remain unchanged.\n- The available one-operand instructions and their results are:\n    - `dec reg`: `reg` minus $1$\n    - `inc reg`: `reg` plus $1$\n    - `not reg`: bitwise NOT of `reg`\n- The available two-operand instructions and their results are:\n    - `and reg1 reg2`: bitwise AND of `reg1` and `reg2`\n    - `or reg1 reg2`: bitwise OR of `reg1` and `reg2`\n    - `xor reg1 reg2`: bitwise XOR of `reg1` and `reg2`\n    - `shl reg1 reg2`: `reg1` shifted left by `reg2` bits (and inserts `reg2` $0$-s as the least significant bits)\n    - `shr reg1 reg2`: `reg1` shifted right by `reg2` bits (and inserts `reg2` $0$-s as the most significant bits)\n    - `add reg1 reg2`: `reg1` plus `reg2`\n    - `sub reg1 reg2`: `reg1` minus `reg2`\n    - `mul reg1 reg2`: `reg1` multiplied by `reg2`\n    - `div reg1 reg2`: `reg1` divided by `reg2` (integer division)\n    - `mod reg1 reg2`: `reg1` modulo `reg2` (remainder of `reg1` after division by `reg2`)\n    - `mov reg1 reg2`: `reg2` (the instruction copies the value of `reg2` to `reg1`)\n- The only operations where the result could overflow are `shl`, `add`, `sub`, `mul`, `inc` and `dec`. In `sub` and `dec`, the result of $i-j$ modulo $2^b$ for $j \\gt i$ is $2^b + i - j$. In all other instructions, modulo simply corresponds to discarding all except the least significant $b$ bits.\n- It is not allowed to use the `div` or `mod` operation if `reg2` contains $0$.\n\nInitially, all four registers contain $0$-s. You are given $N$ triplets of 64-bit integers $(a_1, b_1, c_1), (a_2, b_2, c_2), \\ldots, (a_N, b_N, c_N)$ and you should write a program (a sequence of instructions) such that each triplet appears in the registers at some point during the execution of this program. The order in which they appear does not matter. Formally, for each valid $i$, there should be an instruction in your program such that **immediately** after this instruction is executed, one of the registers contains the value $a_i$, one contains $b_i$ and one contains $c_i$ (the fourth register may contain anything).\n\n### Input\n- The first line of the input contains a single integer $N$.\n- $N$ lines follow. For each $i$ ($1 \\le i \\le N$), the $i$-th of these lines contains three space-separated integers $a_i$, $b_i$ and $c_i$.\n\n### Output\n- First, print a line containing a single integer $P$ \u2015 the number of instructions in your program.\n- Then, print $P$ lines. For each valid $i$, the $i$-th of these lines should contain the $i$-th instruction from your program in the format described above.\n\n### Constraints\n- $N = 64$\n- $0 \\le a_i, b_i, c_i \\lt 2^{64}$ for each valid $i$\n- $a_i \\neq b_i$, $b_i \\neq c_i$, $a_i \\neq c_i$ for each valid $i$\n\n### Scoring\nIf your program attempts to divide anything by zero or compute anything modulo zero, your submission will receive the Wrong Answer verdict.\n\nIf $P$ exceeds $N \\cdot 500$, your submission will also receive the Wrong Answer verdict. Otherwise, the score of your program is equal to $P$. Your goal is to minimise this number.\n\nThere are ten test files. During the contest, the displayed score will account for exactly three test files. However, if your program gets a non-AC verdict on any test file, your submission's verdict will be non-AC. In other words, an AC verdict denotes that your program runs successfully on all the test files. After the end of the contest, your score will be changed to include the sum of your program's scores over the other 7 test files.\n\n### Generation\nThere are five types of test files and two files of each type.\n- Type 1: Each triplet is chosen uniformly randomly among all valid triplets.\n- Type 2: For each valid $i$:\n    - $a_i$ is chosen uniformly randomly among all 64-bit integers which contain at least 25 0-bits and at least 25 1-bits.\n    - $b_i$ and $c_i$ are chosen uniformly randomly among all pairs of distinct 64-bit integers which only differs from $a_i$ in one or two bits.\n- Type 3: For each valid $i$:\n    - If $i = 1 + 8k$ for some integer $k$, an unsigned integer $d$ ($1 \\le d \\lt 2^{63}$) is chosen uniformly randomly. This integer is used for this triplet and the next seven triplets.\n    - First, $a_i$ is chosen uniformly randomly; $b_i = a_i + d$ and $c_i = a_i + 2d$. If $c_i \\ge 2^{64}$, $a_i$ is chosen uniformly randomly again and $b_i$ and $c_i$ are updated.\n    - This process is repeated until $c_i \\lt 2^{64}$.\n- Type 4:\n    - First, three 64-bit unsigned integers are chosen uniformly randomly and assigned to three registers. The fourth register is unused; we may assume that it does not exist. Consider the following program which generates a list $L$:\n        - If $L$ contains $9N$ integers, terminate.\n        - Randomly choose two registers in some order. Randomly choose to use the whole registers or their lower 32 bits.\n        - Randomly choose one of the instructions `xor`, `and`, `or`, `add` or `sub` and execute it with the chosen registers as operands.\n        - Add the values in the three registers (in a fixed order) to the list $L$.\n    - Consider every third element of the list $L$. The first three of these integers form the first triplet, the next three form the second triplet and so on.\n    - While any triplet contains two equal elements, this process is repeated and the triplets regenerated.\n- Type 5:\n    - A 64-bit unsigned integer $K$ is chosen uniformly randomly.\n    - Each triplet is chosen uniformly randomly among all valid triplets with sum of all three elements equal to $K$.\n\n### Example Input 1\n```\n3\n255 2 4\n1 0 3\n2 6 3\n```\n\n### Example Output 1\n```\n10\ndec al\ninc rcx\ninc ecx\nmov rdx rcx\nadd rcx rdx\nadd rcx rdx\nmov rbx rcx\ndiv rbx rdx\ndiv rdx rdx\ndiv rcx rax\n```\n\n### Example Input 2\n```\n1\n18446743995541146810 18446743995541146811 18446743995541146809\n```\n\n### Example Output 2\n```\n13\ndec ebx\nadd bx bx\nmul rbx rbx\nnot ebx\nsub eax ebx\ndiv ebx eax\nmul ebx ebx\nsub ebx eax\nmul rax rbx\nmov rdx rax\ndec rax\nmov rbx rax\ndec rbx\n```\n\n### Explanation\nNote that $N \\neq 64$ to keep the input short. This constraint holds for all input files.\n\n**Example case 1:** The 64-bit values stored in the registers `(rax, rbx, rcx, rdx)` after each instruction is executed are as follows:\n```\ndec al                 (255, 0, 0, 0)\ninc rcx                (255, 0, 1, 0)\ninc ecx                (255, 0, 2, 0)\nmov rdx rcx            (255, 0, 2, 2)\nadd rcx rdx            (255, 0, 4, 2) \u2015 the first triplet appears\nadd rcx rdx            (255, 0, 6, 2)\nmov rbx rcx            (255, 6, 6, 2)\ndiv rbx rdx            (255, 3, 6, 2) \u2015 the third triplet appears\ndiv rdx rdx            (255, 3, 6, 1)\ndiv rcx rax            (255, 3, 0, 1) \u2015 the second triplet appears\n```\n","inputFormat":"","inputFormatState":false,"outputFormat":"","outputFormatState":false,"sampleTestCases":[]},"video_editorial_url":"","languages_supported":"CPP14, C, JAVA, PYTH 3.6, PYTH, PYP3, CS2, ADA, PYPY, TEXT, PAS fpc, NODEJS, RUBY, PHP, GO, HASK, TCL, PERL, SCALA, LUA, kotlin, BASH, JS, LISP sbcl, rust, PAS gpc, BF, CLOJ, R, D, CAML, FORT, ASM, swift, FS, WSPC, LISP clisp, SQL, SCM guile, PERL6, ERL, CLPS, ICK, NICE, PRLG, ICON, COB, SCM chicken, PIKE, SCM qobi, ST, NEM","max_timelimit":"5","source_sizelimit":"50000","problem_author":"istva_adm","problem_author_html_handle":"<span \n            class='rating' \n            style='display: inline-block; \n                    font-size: 10px; \n                    background: #666666;\n                    padding: 0 3px; \n                    line-height: 1.3; \n                    color: white;\n                    margin-right: 2px;'>1&#9733;<\/span><span class='m-username--link'>istva_adm<\/span>","problem_tester":null,"problem_tester_html_handle":"","date_added":"26-08-2019","tags":"<a class='problem-tag-small ' href='\/tags\/problems\/istva_adm'>istva_adm<\/a>","problem_difficulty_level":"Unavailable","user_zen_mode":false,"best_tag":"","editorial_url":"","time":{"view_start_date":1568626202,"submit_start_date":1568626202,"visible_start_date":1568626202,"end_date":1735669800,"current":1643798007},"user":{"username":null,"access":"default"},"todo":false,"problem_status":"unattempted","is_direct_submittable":false,"problemDiscussURL":"https:\/\/discuss.codechef.com\/search?q=SEBICPU","is_proctored":false,"is_user_verified_for_proctoring":null,"visitedContests":[]}