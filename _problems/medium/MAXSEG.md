---
{"category_name":"medium","problem_code":"MAXSEG","problem_name":"MAX-SEG","problemComponents":{"constraints":"- $1\\le T  \\le 10$ \n- $1\\le N, Q  \\le 5 \\cdot10^5$ \n- $|A_i| \\le 10^9 $\n- $0\\le B_i \\le1$\n- $1 \\le L \\le R \\le N$\n- Sum of $N$ over all test cases does not exceed $5\\cdot10^5$\n- Sum of $Q$ over all test cases does not exceed $5\\cdot10^5$\n","constraintsState":true,"subtasks":"**Subtask #1 (5 points)**\n- $1\\le N \\le 1000$\n- $Q = 1$\n- Sum of $N$ over all test cases does not exceed $10^3$\n\n**Subtask #2 (30 points)**\n- $1\\le N \\le 5 \\cdot 10^5$\n- $Q = 1$\n- Sum of $N$ over all test cases does not exceed $5\\cdot10^5$\n\n**Subtask #3 (65 points)**\n- Original constraints\n","subtasksState":true,"inputFormat":"- The first line contains an integer $T$, denoting the number of test cases. The $T$ test cases then follow:\n- The first line of each test case contains two space-separated integers $N, Q$.\n- The second line contains $N$ space-separated integers $A_1, A_2,\\dots, A_N$.\n- The third line contains $N$ space-separated integers $B_1, B_2,\\dots, B_N$.\n- $Q$ lines follow, each containing two space-separated integers $L, R$.","inputFormatState":true,"outputFormat":"For each query, output in a single line the maximum goodness of a partition of $[L, R]$. If there is no possible partition, print $0$. ","outputFormatState":true,"sampleTestCases":{"0":{"id":1,"input":"1\n5 1\n1 1 1 1 2\n1 1 0 1 1\n2 5","output":3,"explanation":"**Test Case $1$:** We can divide the subarray $[2, 5]$ into $[2,3], [4,4] ,[5,5]$.","isDeleted":false}}},"video_editorial_url":"","languages_supported":{"0":"CPP14","1":"C","2":"JAVA","3":"PYTH 3.6","4":"CPP17","5":"PYTH","6":"PYP3","7":"CS2","8":"ADA","9":"PYPY","10":"TEXT","11":"PAS fpc","12":"NODEJS","13":"RUBY","14":"PHP","15":"GO","16":"HASK","17":"TCL","18":"PERL","19":"SCALA","20":"LUA","21":"kotlin","22":"BASH","23":"JS","24":"LISP sbcl","25":"rust","26":"PAS gpc","27":"BF","28":"CLOJ","29":"R","30":"D","31":"CAML","32":"FORT","33":"ASM","34":"swift","35":"FS","36":"WSPC","37":"LISP clisp","38":"SQL","39":"SCM guile","40":"PERL6","41":"ERL","42":"CLPS","43":"ICK","44":"NICE","45":"PRLG","46":"ICON","47":"COB","48":"SCM chicken","49":"PIKE","50":"SCM qobi","51":"ST","52":"SQLQ","53":"NEM"},"max_timelimit":1,"source_sizelimit":50000,"problem_author":"tle_99","problem_tester":"","date_added":"19-10-2021","tags":{"0":"binary","1":"binary","2":"ltime101","3":"medium","4":"tle_99"},"problem_difficulty_level":"Unavailable","best_tag":"Binary Search","editorial_url":"https://discuss.codechef.com/problems/MAXSEG","time":{"view_start_date":1635354000,"submit_start_date":1635354000,"visible_start_date":1635354000,"end_date":1735669800},"is_direct_submittable":false,"problemDiscussURL":"https://discuss.codechef.com/search?q=MAXSEG","is_proctored":false,"visitedContests":{},"layout":"problem"}
---
Given two arrays $A$ and $B$ of size $N$, array $B$ contains only ${0,1}$. You are given $Q$ queries,in each query you are given $i,j$.
For each query you have to partition sub array $A[i,..,j]$ into some contiguous segments such that, segments are non-intersecting and each element must belong to exactly one segment and each segment must follow the given condition:
<br />
<br />
Let [l,r] be one of such a segment then $B[l]$ + $B[l+1]$ + $B[l+2]$ +..+ $B[r]$ should be equal to 1.
<br />
<br />
Let's define sum(l,r) = $A[l]$+$A[l+1]$+$A[l+2]$+..+$A[r]$. Your goal is to partition  sub array $A[i,..,j]$ into segments such that it must follow the given condition and you have to maximize the number of segments with non-negative sum. 
<br />
<br />
Finally for each query print the maximum number of segments with non-negative sum, without violating the above condition.
<aside style='background: #f8f8f8;padding: 10px 15px;'><div>All submissions for this problem are available.</div></aside>