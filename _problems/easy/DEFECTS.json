{"category_name":"easy","status":"success","problem_code":"DEFECTS","problem_name":"Invincible Shield","body":"Greed has an invincible shield due to which the attacks of Edward would not work on him. But Edward being a prodigy has caught onto the flaws in Greed's shield. The shield is made up of the same fundamental element, by which all other life forms are formed, Carbon.\r\n  \r\nHe observed that Greed's shield can be represented as a grid $G$ of carbon clusters with $N$ rows and $M$ columns. Each cell on the grid represents the orientation of the carbon cluster, either $0$ or $1$. Specifically, $G_{i, j}$ denote the $j$-th carbon cluster in $i$-th row.\r\n\r\nThe shield is penetrable only when all the carbon clusters in the shield grid have the same orientation. \r\n\r\nFor achieving this, Initially, he chooses a single carbon cluster (ie. a single cell) in the shield. Now, he repeatedly applies the following move on this cluster, till all the carbon clusters in the grid have the same orientation:\r\n\r\nIn a single move, Edward flips the orientation of all clusters reachable from the chosen cluster. A cluster is called reachable from another cluster, if both clusters have the same orientation, and it is possible to move from one cluster to the other through clusters of that orientation only, moving vertically and horizontally. If earlier the orientation was $1$, it turns into $0$ and vice versa.\r\n\r\nChoosing the start cell optimally, can you find the minimum number of moves to make all the clusters have same orientation?\r\n\r\nDo not worry, you do not need to know about Carbon clusters in order to solve this problem.\r\n\r\n### Input:\r\n- The first line contains $T$, the number of test cases. Then the test cases follow. \r\n- For each test case, the first line contains $N$ and $M$ denoting the number of rows and columns of grid $G$ depicting the shield of Greed.\r\n- For each test case, $N$ lines follow, each line containing $M$ integers where the $j$-th integer in $i$-th line depicts the initial orientation of the $G_{i, j}$ cluster.\r\n\r\n### Output:\r\nFor each test case, output a single integer in a separate line denoting the minimum number of moves required to make the complete shield of a single orientation.\r\n\r\n### Constraints \r\n- $1\\leq T\\leq 10$  \r\n- $1 \\leq N,M \\leq 50$\r\n- $0 \\leq G_{i, j} \\leq 1$ for $1 \\leq i \\leq N$ and $1 \\leq j \\leq M$\r\n\r\n### Sample Input:\r\n```\r\n4\r\n6 6\r\n0 0 0 1 1 1\r\n0 0 0 1 1 0\r\n0 0 0 0 0 0\r\n1 1 1 1 1 1\r\n1 1 0 0 0 0\r\n1 1 1 0 0 0\r\n4 3\r\n1 1 1\r\n1 1 1\r\n1 1 1\r\n1 1 1\r\n2 4\r\n0 0 0 0\r\n1 1 1 1\r\n1 5\r\n1 0 1 0 1\r\n```\r\n\r\n### Sample Output:\r\n```\r\n2\r\n0\r\n1\r\n2\r\n```\r\n### Explanation:\r\n- Testcase $1$: Choosing $G_{1, 1}$ as the start point, the whole shield gets orientation $0$ in $2$ moves.\r\n\r\nAfter the first move, the grid would look like:\r\n```\r\n1 1 1 1 1 1\r\n1 1 1 1 1 1\r\n1 1 1 1 1 1\r\n1 1 1 1 1 1\r\n1 1 0 0 0 0\r\n1 1 1 0 0 0\r\n```\r\n\r\nAfter the second move, the grid would look like:\r\n```\r\n0 0 0 0 0 0\r\n0 0 0 0 0 0\r\n0 0 0 0 0 0\r\n0 0 0 0 0 0\r\n0 0 0 0 0 0\r\n0 0 0 0 0 0\r\n```\r\n\r\nThere are many other starting points which lead to the optimal minimal number of moves as well.\r\n- Testcase $2$: The shield is already of same orientation, so $0$ moves.\r\n- Testcase $3$: Choosing $G_{1, 1}$ as the start point, the whole shield gets orientation $1$ in $1$ move.\r\n- Testcase $4$: Choosing $G_{1, 3}$ as the start point, the whole shield gets orientation $1$ in $2$ move.\n<aside style='background: #f8f8f8;padding: 10px 15px;'><div>All submissions for this problem are available.<\/div><\/aside>","problemComponents":{"constraints":"","constraintsState":false,"subtasks":"","subtasksState":false,"statement":"Greed has an invincible shield due to which the attacks of Edward would not work on him. But Edward being a prodigy has caught onto the flaws in Greed's shield. The shield is made up of the same fundamental element, by which all other life forms are formed, Carbon.\r\n  \r\nHe observed that Greed's shield can be represented as a grid $G$ of carbon clusters with $N$ rows and $M$ columns. Each cell on the grid represents the orientation of the carbon cluster, either $0$ or $1$. Specifically, $G_{i, j}$ denote the $j$-th carbon cluster in $i$-th row.\r\n\r\nThe shield is penetrable only when all the carbon clusters in the shield grid have the same orientation. \r\n\r\nFor achieving this, Initially, he chooses a single carbon cluster (ie. a single cell) in the shield. Now, he repeatedly applies the following move on this cluster, till all the carbon clusters in the grid have the same orientation:\r\n\r\nIn a single move, Edward flips the orientation of all clusters reachable from the chosen cluster. A cluster is called reachable from another cluster, if both clusters have the same orientation, and it is possible to move from one cluster to the other through clusters of that orientation only, moving vertically and horizontally. If earlier the orientation was $1$, it turns into $0$ and vice versa.\r\n\r\nChoosing the start cell optimally, can you find the minimum number of moves to make all the clusters have same orientation?\r\n\r\nDo not worry, you do not need to know about Carbon clusters in order to solve this problem.\r\n\r\n### Input:\r\n- The first line contains $T$, the number of test cases. Then the test cases follow. \r\n- For each test case, the first line contains $N$ and $M$ denoting the number of rows and columns of grid $G$ depicting the shield of Greed.\r\n- For each test case, $N$ lines follow, each line containing $M$ integers where the $j$-th integer in $i$-th line depicts the initial orientation of the $G_{i, j}$ cluster.\r\n\r\n### Output:\r\nFor each test case, output a single integer in a separate line denoting the minimum number of moves required to make the complete shield of a single orientation.\r\n\r\n### Constraints \r\n- $1\\leq T\\leq 10$  \r\n- $1 \\leq N,M \\leq 50$\r\n- $0 \\leq G_{i, j} \\leq 1$ for $1 \\leq i \\leq N$ and $1 \\leq j \\leq M$\r\n\r\n### Sample Input:\r\n```\r\n4\r\n6 6\r\n0 0 0 1 1 1\r\n0 0 0 1 1 0\r\n0 0 0 0 0 0\r\n1 1 1 1 1 1\r\n1 1 0 0 0 0\r\n1 1 1 0 0 0\r\n4 3\r\n1 1 1\r\n1 1 1\r\n1 1 1\r\n1 1 1\r\n2 4\r\n0 0 0 0\r\n1 1 1 1\r\n1 5\r\n1 0 1 0 1\r\n```\r\n\r\n### Sample Output:\r\n```\r\n2\r\n0\r\n1\r\n2\r\n```\r\n### Explanation:\r\n- Testcase $1$: Choosing $G_{1, 1}$ as the start point, the whole shield gets orientation $0$ in $2$ moves.\r\n\r\nAfter the first move, the grid would look like:\r\n```\r\n1 1 1 1 1 1\r\n1 1 1 1 1 1\r\n1 1 1 1 1 1\r\n1 1 1 1 1 1\r\n1 1 0 0 0 0\r\n1 1 1 0 0 0\r\n```\r\n\r\nAfter the second move, the grid would look like:\r\n```\r\n0 0 0 0 0 0\r\n0 0 0 0 0 0\r\n0 0 0 0 0 0\r\n0 0 0 0 0 0\r\n0 0 0 0 0 0\r\n0 0 0 0 0 0\r\n```\r\n\r\nThere are many other starting points which lead to the optimal minimal number of moves as well.\r\n- Testcase $2$: The shield is already of same orientation, so $0$ moves.\r\n- Testcase $3$: Choosing $G_{1, 1}$ as the start point, the whole shield gets orientation $1$ in $1$ move.\r\n- Testcase $4$: Choosing $G_{1, 3}$ as the start point, the whole shield gets orientation $1$ in $2$ move.","inputFormat":"","inputFormatState":false,"outputFormat":"","outputFormatState":false,"sampleTestCases":[]},"video_editorial_url":"","languages_supported":"CPP14, C, JAVA, PYTH 3.6, CPP17, PYTH, PYP3, CS2, ADA, PYPY, TEXT, PAS fpc, NODEJS, RUBY, PHP, GO, HASK, TCL, PERL, SCALA, LUA, kotlin, BASH, JS, LISP sbcl, rust, PAS gpc, BF, CLOJ, R, D, CAML, FORT, ASM, swift, FS, WSPC, LISP clisp, SQL, SCM guile, PERL6, ERL, CLPS, ICK, NICE, PRLG, ICON, COB, SCM chicken, PIKE, SCM qobi, ST, SQLQ, NEM","max_timelimit":"1.5","source_sizelimit":"50000","problem_author":"sachin_yadav","problem_author_html_handle":"<span \n            class='rating' \n            style='display: inline-block; \n                    font-size: 10px; \n                    background: #684273;\n                    padding: 0 3px; \n                    line-height: 1.3; \n                    color: white;\n                    margin-right: 2px;'>4&#9733;<\/span><span class='m-username--link'>sachin_yadav<\/span>","problem_tester":null,"problem_tester_html_handle":"","date_added":"20-10-2019","tags":"<a class='problem-tag-small ' href='\/tags\/problems\/bipartite'>bipartite<\/a>, <a class='problem-tag-small ' href='\/tags\/problems\/breadth-first-search'>breadth-first-search<\/a>, <a class='problem-tag-small ' href='\/tags\/problems\/dcod2019'>dcod2019<\/a>, <a class='problem-tag-small ' href='\/tags\/problems\/graphs'>graphs<\/a>, <a class='problem-tag-small ' href='\/tags\/problems\/sachin_yadav'>sachin_yadav<\/a>, <a class='problem-tag-small ' href='\/tags\/problems\/sachin_yadav'>sachin_yadav<\/a>","problem_difficulty_level":"Easy","user_zen_mode":false,"best_tag":"Breadth First Search","editorial_url":"https:\/\/discuss.codechef.com\/problems\/DEFECTS","time":{"view_start_date":1572633000,"submit_start_date":1572633000,"visible_start_date":1572633000,"end_date":1735669800,"current":1643797799},"user":{"username":null,"access":"default"},"todo":false,"problem_status":"unattempted","is_direct_submittable":false,"problemDiscussURL":"https:\/\/discuss.codechef.com\/search?q=DEFECTS","is_proctored":false,"is_user_verified_for_proctoring":null,"visitedContests":[]}